{%- import "common.hpp.in" as common %}

#include "{{ cls_.name }}.hpp"
{% for ns, cl in cls_.get_forward_decls() -%}
#include "{{ ns + '/' + cl }}.hpp"
{% endfor %}

namespace gir {
namespace {{ cls_.namespace.name }} {

{% for m in cls_.get_plain_methods() %}
{{ common.method_def(cls_, m) }}
{
    {% if m.throws -%}
    GError *err{};
    {%- endif %}

    {% if m.has_return() -%}
    {{ m.return_value.c_type }} r =
    {%- endif %}

    {{ m.c_ident }}(
    {% for pname, ptype in m.c_params %}
        {{ ptype.cast_to_c(pname) }}
        {{- "," if not loop.last else "" }}
    {% endfor -%}
    {% if m.throws %}
        , &err
    {% endif %}
    );

    {% if m.throws -%}
    if (err)
    {
        Error e{err};
        g_error_free(err);
        throw e;
    }
    {%- endif %}

    {% if m.has_return() -%}
    return {{ m.return_value.cast_from_c("r") }};
    {%- endif %}
}
{% endfor %}

{% for m in cls_.get_signals() %}
guint
{{cls_.name}}::on_{{ m.get_name() }}({{ common.signal_signature(cls_, m) }} func)
{
    using FuncT = decltype(func);
    FuncT *func_ = new FuncT(func);

    using CbT =
        {{ m.return_value.cpp_type() }}(*)(
            {{ common.signal_params(cls_, m) }}
            , gpointer data
        );
    CbT cb = [](
            {{ common.signal_params(cls_, m) }}
            , gpointer data) {
        FuncT *func = reinterpret_cast<FuncT *>(data);
        return (*func)(
                    inst
                    {%- for pname, _ in m.params %}
                    , {{ pname -}}
                    {% endfor -%}
                );
    };

    auto notify = [](gpointer data, GClosure *) {
        FuncT *func = reinterpret_cast<FuncT *>(data);
        delete func;
    };

    return g_signal_connect_data(_g_obj, "{{ m.name }}", G_CALLBACK(cb), func_, notify, G_CONNECT_AFTER);
}
{% endfor %}

} //namespace {{ cls_.namespace.name }};
} //namespace gir;
