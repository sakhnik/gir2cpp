#pragma once

{%- import "common.hpp.in" as common %}

#include "gir/Base.hpp"
#include "aliases.hpp"
{% for inc in cls_.get_header_includes() -%}
#include "{{ inc }}.hpp"
{% endfor %}
{%- if cls_.get_signals() -%}
#include <functional>
{% endif %}

namespace gir {

{% for ns,cl in cls_.get_forward_decls() -%}
namespace {{ ns }} { class {{ cl }}; }
{% endfor %}

namespace {{ cls_.namespace.name }} {

class {{ cls_.name }}
    : public virtual gir::Base
{%- for p in cls_.get_parents() %}
    , public {{ p }}
{%- endfor %}
{
public:
    {{ cls_.name }}(::GObject *o = nullptr)
    {
        _g_obj = o;
    }

    //{{ cls_.name }}({{ cls_.name }} &&o)
    //    : gir::Base{o}
    //{
    //    _g_obj = o._g_obj;
    //    o._g_obj = nullptr;
    //}

    //{{ cls_.name }}(const {{ cls_.name }} &o)
    //    : gir::Base{o}
    //{
    //    _g_obj = o._g_obj;
    //}

    //{{ cls_.name }}& operator=({{ cls_.name }} &&o)
    //{
    //    _g_obj = o._g_obj;
    //    o._g_obj = nullptr;
    //    return *this;
    //}

    //{{ cls_.name }}& operator=(const {{ cls_.name }} &o)
    //{
    //    _g_obj = o._g_obj;
    //    return *this;
    //}

    {% for m in cls_.get_plain_methods() %}
    {{ common.method_decl(m) }}
    {% endfor %}

    {% for m in cls_.get_signals() %}
    {{ common.signal_decl(cls_, m) }}
    {% endfor %}
};

} //namespace {{ cls_.namespace.name }};
} //namespace gir;
